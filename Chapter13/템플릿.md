# Chapter15 - 제네릭 프로그래밍 : 템플릿 
## 🐳15.1 함수 템플릿
### 💠15.1.1. 함수 템플릿의 필요성
템플릿 프로그래밍(제네릭 프로그래밍)을 사용하지 않으면 여러개의 함수를 정의해야 한다.
#### 여러 개의 함수 오버로드하기

🖥️ _작은 것을 찾는 smaller함수를 자료형 별로 구현한 프로그램.cpp_
```cpp
#include <iostream>

char smaller(char first, char second)
{
    if(first < second )
    {
        return first;
    }
    return second
}
// 두 정수 중 작은것을 찾는 함수
int smaller(int first, int second)
{
    if(first < second)
    {
        return first
    }
    return second;
}
```
- C에서는 같은 기능이라도 자료형마다 함수를 따로 만들어야 했다
- 중복이 많다

### 💠15.1.2. 함수 템플릿(Function Template)
#### 개념
함수 템플릿은 **자료형에 독립적인 함수를 작성할 수 있게 해주는 문법**
함수 로직은 하나지만, 호출 시점에 **컴파일러가 자료형에 맞는 함수 버전을 자동으로 만들어준다**

#### 문법 구조
```cpp
template <typename T>   // 또는 template <class T>
T add(T a, T b){
    return a + b;
}
```
- `template <typename T>` : "아래 함수는 T라는 자료형에 대해 일반화 되어 있다"
- `T add(T a, T b)` : 반환형과 매개변수 타입도 T
- 함수 안에서는 **T를 실제 자료형처럼 사용 가능**

🖥️ _템플릿 함수를 적용한 smaller.cpp_
```cpp
template <typename T>
T smaller(T first, T second){
    if(first < second)
    {
        return first;
    }
    return second;
}

int main()
{
    std::cout << smaller('a', 'b') << std::endl;    // char 버전 호출
    std::cout << smaller(12, 15) << std::endl;      // int 버전 호출
    std::cout << smaller(44.2, 33.1) << std::endl;  // double 버전 호출
    return 0;
}
```
-  **컴파일러가 자동으로 int버전과 double버전을 생성**
- 값으로 전달이 아니라 참조로 전달로 코드를 작성하고 싶으면 `T`를 `T&`로 변경하면 된다.

### 💠15.1.3. 템플릿 인스턴스화
> **템플릿으로 일반화된 코드를 실제 자료형으로 구체화하는 과정**

- **T에 실제 자료형을 넣어 컴파일러가 진짜 함수를 만들어주는 과정**
- C++ 에서는 두 가지 방식이 있다.
#### 1. 암시적(implicit)인스턴스화
그냥 함수 호출만 하면 컴파일러가 자동으로 만들어준다
```cpp
add(3, 4);       // int 버전 자동 생성
add(2.5, 3.1);   // double 버전 자동 생성
```
#### 2. 명시적(Explicit) 인스턴스화
- 개발자가 '이 타입으로 꼭 만들어달라'고 명시
- 주로 라이브러리 구현에서 사용한다
```cpp
template int add<int>(int, int);     // int 버전 강제 생성
template double add<double>(double, double);    // double버전 강제 생성
```
- 이렇게 하면 **컴파일러가 실제 함수를 미리 생성한다
- 큰 프로젝트에서 **컴파일 속도를 조절하거나 링커 오류를 막기 위해 사용**
---

## 🐳15.2 함수 템플릿의 변형
### 💠15.2.1 자료형이 아닌 템플릿 매개변수
함수 템플릿으로 자료형이 아닌 값을 정의할 수도 있다.
이렇게 값으로 정의해서 사용할 경우, 매개변수를 전달하는 것과 비슷한 역할을 한다.

🖥️ _요소의 종류나 배열의 크기와 관계없이 출력.cpp_
```cpp
template<typename T, int N>
void print(T(&array)[N])
{
    for(int i = 0; i < N; i++)
    {
        cout << array[i] << " ";
    }
    cout << endl;
}

int main()
{
    int arr1[4] = {7, 3, 5, 1};
    double arr2[3] = {7.5, 6.1, 4.6};

    print(arr1);
    print(arr2);
}
```
- `template<typename T, int N>` : 템플릿 매개변수
     - **T** : 배열 요소의 자료형을 일반화</br>
     int, double, char등 모든 자료형을 받을 수 있다.
     - **N** : 배열의 크기를 일반화</br>
     배열 길이가 달라도 한 함수로 처리 가능
- `T(&array)[N]` : 배열을 참조(reference)로 전달할 때 사용
    - `T(array)[N]`가 아닌 `T(array&)[N]`인 이유 : 
    - 함수 안에서 배열 크기를 알고싶기 때문 : N사용 가능
    - 배열 전체를 복사하지 않고 원본 배열 참조 → 성능 최적화