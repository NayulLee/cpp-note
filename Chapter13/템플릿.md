# Chapter15 - 제네릭 프로그래밍 : 템플릿 
## 🐳15.1 함수 템플릿
### 💠15.1.1. 함수 템플릿의 필요성
템플릿 프로그래밍(제네릭 프로그래밍)을 사용하지 않으면 여러개의 함수를 정의해야 한다.
#### 여러 개의 함수 오버로드하기

🖥️ _작은 것을 찾는 smaller함수를 자료형 별로 구현한 프로그램.cpp_
```cpp
#include <iostream>

char smaller(char first, char second)
{
    if(first < second )
    {
        return first;
    }
    return second
}
// 두 정수 중 작은것을 찾는 함수
int smaller(int first, int second)
{
    if(first < second)
    {
        return first
    }
    return second;
}
```
- C에서는 같은 기능이라도 자료형마다 함수를 따로 만들어야 했다
- 중복이 많다

### 💠15.1.2. 함수 템플릿(Function Template)
#### 개념
함수 템플릿은 **자료형에 독립적인 함수를 작성할 수 있게 해주는 문법**
함수 로직은 하나지만, 호출 시점에 **컴파일러가 자료형에 맞는 함수 버전을 자동으로 만들어준다**

#### 문법 구조
```cpp
template <typename T>   // 또는 template <class T>
T add(T a, T b){
    return a + b;
}
```
- `template <typename T>` : "아래 함수는 T라는 자료형에 대해 일반화 되어 있다"
- `T add(T a, T b)` : 반환형과 매개변수 타입도 T
- 함수 안에서는 **T를 실제 자료형처럼 사용 가능**

🖥️ _템플릿 함수를 적용한 smaller.cpp_
```cpp
template <typename T>
T smaller(T first, T second){
    if(first < second)
    {
        return first;
    }
    return second;
}

int main()
{
    std::cout << smaller('a', 'b') << std::endl;    // char 버전 호출
    std::cout << smaller(12, 15) << std::endl;      // int 버전 호출
    std::cout << smaller(44.2, 33.1) << std::endl;  // double 버전 호출
    return 0;
}
```
-  **컴파일러가 자동으로 int버전과 double버전을 생성**
- 값으로 전달이 아니라 참조로 전달로 코드를 작성하고 싶으면 `T`를 `T&`로 변경하면 된다.

### 💠15.1.3. 템플릿 인스턴스화
> **템플릿으로 일반화된 코드를 실제 자료형으로 구체화하는 과정**

- **T에 실제 자료형을 넣어 컴파일러가 진짜 함수를 만들어주는 과정**
- C++ 에서는 두 가지 방식이 있다.
#### 1. 암시적(implicit)인스턴스화
그냥 함수 호출만 하면 컴파일러가 자동으로 만들어준다
```cpp
add(3, 4);       // int 버전 자동 생성
add(2.5, 3.1);   // double 버전 자동 생성
```
#### 2. 명시적(Explicit) 인스턴스화
- 개발자가 '이 타입으로 꼭 만들어달라'고 명시
- 주로 라이브러리 구현에서 사용한다
```cpp
template int add<int>(int, int);     // int 버전 강제 생성
template double add<double>(double, double);    // double버전 강제 생성
```
- 이렇게 하면 **컴파일러가 실제 함수를 미리 생성한다
- 큰 프로젝트에서 **컴파일 속도를 조절하거나 링커 오류를 막기 위해 사용**
---

## 🐳15.2 함수 템플릿의 변형
### 🐻‍❄️복습) C/C++에서 배열을 함수에 전달하는 방법
#### 1. 배열 이름 자체를 매개변수로 전달
```cpp
void foo(int arr[]) {}
```
- C에서는 사실 *배열 이름은 포인터로 변환된다_
- 위 코드는 사실상 `void foo(int* arr) {}` 이 된다.
- 간단하지만 **함수 내부에서는 배열 크기정보를 알 수 없다는 단점**

#### 2. 배열 포인터를 명시적으로 받기
```cpp
void foo(int* arr, int size){
    for(int i = 0; i < size; i++)
    {
        cout << arr[i] << " ";
    }
}
```
- 포인터 + 별도 크기 매개변수
- 크기를 전달해야 배열 전체를 처리 가능하다

#### 3. 배열 참조(reference)로 받기 (C++만 가능)
```cpp
void foo(int(&arr)[5])
{
    for(int i = 0; i < 5; i++)
    {
        cout << arr[i] << " ";
    }
}
```
- 배열을 복사하지 않고 **참조로 전달**
- 배열 크기를 **타입에 포함시킬 수 있음** → N처럼 템플릿에서 바로 사용 가능하다
- 함수 내부에서 `sizeof(arr) / sizeof(arr[0])` 안 써도 된다.
- 함수 호출 시 배열 크기가 다른 경우 발생하는 컴파일 에러에서 안전하다


### 💠15.2.1 자료형이 아닌 템플릿 매개변수
함수 템플릿으로 자료형이 아닌 값을 정의할 수도 있다.
이렇게 값으로 정의해서 사용할 경우, 매개변수를 전달하는 것과 비슷한 역할을 한다.

🖥️ _요소의 종류나 배열의 크기와 관계없이 출력.cpp_
```cpp
template<typename T, int N>
void print(T(&array)[N])
{
    for(int i = 0; i < N; i++)
    {
        cout << array[i] << " ";
    }
    cout << endl;
}

int main()
{
    int arr1[4] = {7, 3, 5, 1};
    double arr2[3] = {7.5, 6.1, 4.6};

    print(arr1);
    print(arr2);
}
```
- `template<typename T, int N>` : 템플릿 매개변수
     - **T** : 배열 요소의 자료형을 일반화</br>
     int, double, char등 모든 자료형을 받을 수 있다.
     - **N** : 배열의 크기를 일반화</br>
     배열 길이가 달라도 한 함수로 처리 가능
- `T(&array)[N]` : 배열을 참조(reference)로 전달할 때 사용
    - 배열을 그냥 `T array[N]`으로 받으면 배열 이름이 포인터로 변환되어 배열 크기 정보를 잃어버리지만
    - 참조를 사용하면 **배열 크기도 타입의 일부로 유지한다**
> 템플릿을 사용하면 배열 이름만 전달해도 **T**와 **N**이 알아서 결정되고, **각 배열 타입+크기 별로 다른 함수 버전이 자동 생성**되는 것이다.

---
### 💠15.2.2. 템플릿 특수화
#### 일반 템플릿 함수
```cpp
template<typename T>
T smaller(const T& first, const T& second)
{
    if(first < second)
        return first;
    return second;
}
```
- T라는 자료형을 일반화한 **템플릿 함수**
- 어떤 자료형이더라도 `<`연산자가 가능하면 `smaller(a, b)`를 호출할 수 있다
    - `int`, `double`, `string`, ...

#### 문제 상황 : C스타일 문자열
C문자열에는 `<`연산자가 정의되어 잇지 않다. 따라서 템플릿 함수를 정의해도
C문자열을 매개변수로 전달해서 비교할 수 없다. 이러한 경우에는 **템플릿 특수화**를 사용한다
```c
const char* s1 = "Bye";
const char* s2 = "ByeBye";
```
- C문자열은 포인터 타입
- 포인터에 `<`연산자를 쓰면 **주소값 비교**를 하게 됨 → 문자열 내용 비교 아님
- 따라서 `const char*` 전용 로직이 필요하다.

🖥️ _템플릿 특수화.cpp_
```cpp
// 템플릿 함수의 특수화를 사용하는 프로그램
#include <iostream>
#include <string>
#include <cstring>

using namespace std;

template<typename T>
T smaller(const T& first, const T& second)
{
    if(first < second)
    {
        return first;
    }
    return second;
}

// 템플릿 함수 특수화
template<>
const char* smaller(const char* const &first, const char* const &second)
{
    /*
    const char* smaller(const char* const &first, const char* const &second)
        - 자료형 앞에 const → 내용(read-only)
        - 포인터 뒤에 const → 포인터 값(read-only)
    const 포인터
        - 포인터가 가리키는 값을 수정할 수 업음
        - 포인터 자체는 다른 주소를 가리킬 수 있음
    포인터 const
        - 포인터 자체를 바꿀 수 없음
        - 가리키는 내용은 수정 가능
    */
    if(strcmp(first, second) < 0)
    {
        return first;
    }
    return second;
}

int main()
{
    string str1 = "Hello";
    string str2 = "Hi";
    cout << "smaller(Hello, Hi) =  " << smaller(str1, str2) << endl;
    // C문자열로 템플릿 함수 호출
    const char* s1 = "Bye";
    const char* s2 = "Bye Bye";
    cout << "smaller(Bye, ByeBye) = " << smaller(s1, s2) << endl;
    return 0;
}
```

## 🐳15.3 클래스 템플릿
> 클래스에는 인터페이스와 구현이 있다.</br>
템플릿 클래스는 일반 클래스와 다르게 **"타입 매개변수"를 같이 적어줘야 한다**

### 💠15.3.1 클래스 템플릿 사용
```cpp
// 인터페이스
template<typename T>
class Name
{
private:
    T data;
public:
    Name();
    T get() const;
    void set(T data);
};
// 구현
template<typename T>    // 템플릿임을 다시 알려준다.
T Name<T>::get() const{     // 반환타입과 클래스 모두 T기반임을 알려준다.
    return data;
    }

template<typename T>
void Name<T>::set(T d){
    data = d;
}
```
- `template<typename T>` : 이 함수는 T라는 템플릿 매개변수를 받는 함수다라고 컴파일러에게 알림
- `T Name<T>::get() const` : "Name"클래스는 T라는 타입을 기반으로 한 템플릿 클래스임을 명시
- 반환 타입도 `T`로 바뀜

```cpp
Name<T>::get()
```
- **T라는 타입을 가진 `Name`클래스의 get함수**라는 의미.


