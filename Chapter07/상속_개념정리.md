# Chapter07 - 상속(Inheritance)
## 🐻‍❄️ 7.1 상속
### 💠7.1.1 정의
|**기존 클래스(부모/기초 클래스)의 특성과 기능을 새로운 클래스(자식/파생 클래스)가 물려받는 것**

코드 재사용성, 유지보수성, 확장성을 높이기 위한 핵심 개념이다.

```cpp
class 부모클래스 {
    // 멤버 변수 및 함수
};

class 자식클래스 : public 부모클래스 {
    // 추가적인 멤버 변수 및 함수
};
```

- 부모의 생성자는 명시적으로 호출하거나 암묵적으로 호출된다.(기본 생성자)
- 소멸자에 `virtual` 붙이기
    - 상속받는 클래스에서 delete할 때 </br>
    **부모 포인터로 자식 객체를 삭제해도 자식 소멸자 호출됨**
- private멤버 접근 불가
    - 자식 클래스는 부모의 `private`멤버에 접근할 수 없다.(getter, setter 통해 우회해야 함)

---
## 🐻‍❄️ 7.2 가상 함수
### 💠7.2.1 virtual 함수
```cpp
virtual void lob(const string& msg) const = 0;
```
| 부모 클래스인 `Logger`에서 선언된 멤버 함수
- `virtual` 키워드를 붙이면</br>
**이 함수는 자식 클래스에서 '재정의'될 수 있음**을 나타낸다.
- 자식 클래스에서 이 함수를 재정의하면</br>**함수를 호출할 때 객체 타입이 아닌, 실제 객체가 어떤 클래스인지 보고 결정한다,**
    - ➡️ **동적 바인딩, 런타임 바인딩**

### 💠7.2.2 가상함수가 필요한 이유
만약 `virtual`이 없으면, 다음과 같이 부모 포인터로 자식 객체를 가리킬 때 **부모 함수가 호출된다**
```cpp
Logger* logger = new ConsoleLogger();
logger->log("message"); // virtual 없으면 Logger::log 호출
```
하지만 멤버함수 `log`에 `virtual`키워드를 붙여주면
**logger**는 `Logger*`타입이지만, 실제 객체는 `ConsoleLogger`이므로
`ConsloeLogger::log`가 호출된다.!

### 💠7.2.3 vtable과 vptr의 이해
클래스에 가상함수가 하나라도 있으면 컴파일러는 다음과 같은 작업을 한다
1. 클래스당 하나의 vtable 생성
    - 이 테이블은 해당 클래스의 가상 함수들을 가리키는 함수 포인터들의 배열
2. 각 객체마다 **vptr**이라는 포인터를 만들어서 **vtable**을 가리키게 한다.
    - 이 **vptr**은 실제로 객체의 첫 번째 멤버처럼 취급된다.

### 💠7.2.4 🖥️ 예제: Polymorph.cpp
```
[ 힙 영역 ] 메모리 레이아웃 구성
┌──────────────────────────┐
│ vptr (가상함수테이블 주소) │  ← Base에서 상속받은 멤버
├──────────────────────────┤
│ Drived 클래스의 멤버 (없음)│
└──────────────────────────┘
```
- `vptr`은 **가상 함수 테이블(vtable)을 가리키는 포인터</br> 가상함수를 사용하기 위해 객체 내부에 숨겨진 멤버로 들어간다.

`drived_prt1->print()` 호출 시:
- 실제 타입은 Drived이므로 vptr은 `Drived`의 vtable을 가리킨다.
- vtable에는 `Drived::print()`가 등록되어 있다.
- 따라서 `Drived::print()` 실행!

---
## 🐻‍❄️7.3 Override
### 💠7.3.1 Override 키워드
```cpp
void log(const string& msg) const override{
    
}
```
|자식 클래스에서 부모의 virtual 함수를 **재정의(=오버라이딩)** 할 때 붙이는 키워드
- 이 함수가 부모의 virtual 함수를 정확히 오버라이딩하고 있다는 걸 컴파일러에게 알리는 것
- 타이핑 실수로 함수 시그니처가 다르다거나, 부모에 해당하는 함수가 없을 경우 컴파일 에러가 난다.

```cpp
void log(string msg) override // string& 빠뜨림 오류!
```
- 부모는 `log(const string& msg)`인데 여기선 `string msg` → 타입이 다르다.
- `override`없으면 새로운 함수로 인식되어버린다.

| **오버라이딩 할 때는 반드시 `override`를 붙이도록 한다.(버그 줄이는데 도움된다.)

---
## 🐻‍❄️7.4 추상 클래스와 `=0` :순수 가상함수
### 💠7.4.1 `= 0`
```cpp
virtual void log(const string& msg) const = 0;
```
| `= 0`은 **이 함수는 구현하지 않겠다**는 
뜻

- **순수 가상함수(pure virtual function)**
- 선언만 하고 **정의(구현)은 안한다**
- 이 함수를 포함한 클래스는 **추상 클래스(abstract class)가 된다.**

### 💠7.4.2 추상 클래스
- 객체를 직접 만들 수 없는 클래스
- 자식 클래스가 이 함수를 반드시 재정의(Override)해야 한다.
- 공통된 인터페이스 역할로 사용한다.
```cpp
Logger logger; // 컴파일 에러, 추상클래스는 객체 생성 불가
Logger* logger = new FileLogger(); // 자식 클래스는 구현을 제공한다
```
- `Logger`클래스는 `log()`함수의 구현을 모르고</br>**자식이 각자 구현하게 강제**하는 것
- `ConsoleLogger`, `FileLogger`는 각각 다르게 log를 처리하게 된다.

---
## 🐻‍❄️7.5 다형성(Polymorphism)
| 같은 이름을 갖는 여러 형태의 함수를 클래스 별로 만들 수 있게 해주는 기능 </br>여러 형태의 함수들이 정의되고 호출 시점에서 어떤 적합한 함수 하나가 호출된다.

- 컴파일 타임 다형성
    - 컴파일러에 의해 호출 함수가 결정됨
    - Function Overloading
    - Operator Overloading
- 런타임 다형성
    - 객체의 생성이나 참조 시점에 호출 함수가 결정됨
    - Virtual Functions
### 💠다형성과 포인터 - 부모 포인터로 자식 객체 다루기
```cpp
void runSystem(Logger* logger)
{
    logger->log("System started.");
}
```
- `runSystem()`함수는 `Logger*` 타입의 포인터를 받는다.
- 그러나 **실제로는 `ConsoleLogger`, `FileLogger`등 자식 객체가 들어올 수 있다**
    - 부모 포인터지만, `virtual`키워드 때문에 **자식의 log()함수가 호출된다**

| 이것을 **다형성(Polymorphism)**이라고 한다.</br>**"같은 인터페이스로 다양한 구현을 한다."**
