# Chapter10 - 연산자 오버로드
> 기본 연산자(+, -, *, /, == 등)을 **클래스 객체에도 적용**하고 싶을 때,</br>**그 연산자를 함수처럼 다시 정의**하는 문법

```cpp
Fraction a(1, 2), b(1, 3);
Fraction c = a + b 
```
- `+`연산자는 원래 정수나 실수용이지만</br>클래스에 맞게 정의하면 객체끼리도 `+`가 가능해진다.

## 🐣10.1 객체의 역할
### ☁️10.1.1 호스트 객체
클래스 멤버 함수를 정의했다면, 인스턴스 앞에 점을 찍고 멤버 함수를 호출한다.
```cpp
void Fun::functionOne(...)
{
    ...
}

int main()
{
    fun1.functionOne(...); // fun1이 호스트 객체
    fun2.functionOne(...); // fun2이 호스트 객체
    fun3.functionOne(...);
}
```
> 호스트 객체는 **함수 호출의 주체**라고 할 수 있다.

---
### ☁️10.1.2 매개변수 객체(parameter object)
매개변수로 전달된 객체.
매개변수는 값으로 전달, 참조로 전달, 포인터로 전달이라는 3가지 방법으로 전달한다.
#### 전달 방법
- 값으로 전달
    - 복사 생성자를 호출하여 객체의 복사본을 만들고, 이를 함수로 전달
    - 복사 비용 크다.
    - 일반적으로 매개변수가 객체일 때는 사용하지 않는다.
- 참조로 전달
    - 사용자 정의 객체를 함수로 전달할 때 사용하는 일반적 방법
    - 값 복사x, 객체에 별칭을 붙여 함수 내부에서 사용할 수 있게 한다.
- 포인터로 전달
    - **객체를 힙에 만들어 객체를 가리키는 포인터가 있을 때 사용**
    - 일반적인 경우에는 사용 안한다.

### ☁️10.1.3 리턴 객체(return object)
생성자와 소멸자는 객체를 리턴하지 않고,
객체를 생성하거나 소멸시키는 역할을 한다.
#### 리턴 방법
객체를 리턴할 때도 값으로 리턴, 참조로 리턴, 포인터로 리턴이라는 3가지 방법을 사용할 수 있다.
- 값으로 리턴
    - 복사 생성자를 호출하여 객체 복사본 만들고 리턴
    - 리턴하는 객체를 함수 내부에서 만들 경우 참조로 리턴과 포인터로 리턴을 사용할 수 없으므로 값으로 리턴만 사용 가능하다.
        - 지역 객체는 함수가 끝나면 메모리에서 사라지기 때문
- 참조로 리턴
    - 복사 비용이 없지만, 함수 내부에서 객체를 생성하는 경우에는 사용 불가
    - 매개변수로 전달받은 객체(or 포인터)와 호스트 객체(or 포인터)를 리턴할 경우는 사용 가능하다.
- 포인터로 리턴
    - 객체를 힙에 만들어서 객체를 가리키는 포인터가 있을 때 사용한다.
    - 일반적인 경우에는 거의 사용 안한다.

### ☁️10.1.4 함수명 앞 const
#### 위치별 const
| 위치                 | 의미                                         |
| ------------------ | ------------------------------------------ |
| 함수명 **뒤** `const`  | **멤버 함수가 객체의 멤버 변수를 변경하지 않겠다**는 약속         |
| 매개변수 **앞** `const` | 해당 매개변수를 함수 내부에서 변경하지 않겠다는 약속              |
| 함수명 **앞** `const`  | **함수가 반환하는 값을 변경할 수 없다**는 뜻 (반환 타입이 const) |

```cpp
class Test
{
public:
    const int getValue() {return 42;}
};

int main()
{
    Test t;
     std::cout << t.getValue() << std::endl; //42
    t.getValue() = 100; // 컴파일 에러
    return 0;
}
```
- 함수명 앞의 const는 사실상 **"반환 타입에 const를 붙인 것"**
- 반환 타입이 포인터나 참조일 때 유용하다.
    - ```cpp
        const string& getName() {return name;}
        ```
    - 이렇게 하면 `getName()`으로 받은 문자열을 수정하려고 하면 오류난다.

---
## 🐣10.2 연산자 오버로드
사용자 정의 타입(클래스, 구조체)을 기본 자료형처럼 자연스럽게 다루기 위함

### ☁️10.2.1 연산자 오버로드를 왜 배우는가
#### 1. 객체를 자연스럽게 사용 가능
- `int a = 3 + 5;`
- `Money m1(1000), m2(2000); m1 + m2;`
    - 둘 다 같은 느낌으로 사용 가능하지만,</br>후자는 클래스에서 `operator+`를 오버로드해야 가능하다.
#### 2. 가독성과 유지보수성 향상
- 연산자 오버로드가 없을때
```cpp
Vector3 pos3 = pos1.add(pos2);
```
- 연산자 오버로드 적용 시
```cpp
Vector3 pos3 = pos1 + pos2;
```
---
### ☁️10.2.2 문법 구조
#### 기본 형태
> 반환형 <span style="color:blueviolet"> operator </span> 연산자(매개변수) { . . . }

- `operator` 키워드 뒤에 오버로드할 연산자를 붙인다.
    - `+`, `-`, `==`, `[]`, `()`, `<<`, `>>`
    - 매개변수 개수는 해당 연산자의 원래 피연산자 수와 맞춘다.

### ☁️10.2.3 멤버 함수 오버로드
> 반환형 <span style="color:blueviolet"> operator </span> 연산자(매개변수) { . . . }
- 왼쪽 피연산자가 해당 클래스 타입일때 호출된다
- `this`를 통해 왼쪽 피연산자에 접근
- 주로 자기 자신의 멤버 변수만으로 연산 가능할 때 사용

```cpp
const Fraction operator+() const;
const Fraction operator-() const;

const Fraction Fraction::operator+() const
{
    Fraction temp(+numer, denum);
    return temp;
}

const Fraction Fraction::operator-() const
{
    Fraction temp(-numer, denum);
    return temp;
}
```
- 맨 앞 `const Fraction` : 리턴 타입
    - 반환값이 `Fraction`객체이고 수정불가
    - 임시 객체를 const로 반환
- `operator+()` : 
    - 단항 + 연산자를 오버로딩
- 맨 끝 `const` : 읽기 전용
    - 멤버 함수를 호출해도 객체 자체를 변경하지 않는다.
> "이 객체를 수정하지 않고, 이 객체를 기반으로 새로운 Fraction객체를 만들어 리턴하는 + 연산자"

#### 전위 증가와 전위 감소 연산자
```cpp
Fraction& operator++();

Fraction& Fraction::operator++()
{
    numer = numer + denom;
    this->normalize();
    return *this;
}

Fraction& operator--();

Fraction& Fraction::operator--()
{
    numer = numer - denom;
    this->normalize();
    return *this;
}
```

### ☁️10.2.3 비멤버 함수 오버로드


