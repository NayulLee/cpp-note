# Chapter10 - 연산자 오버로드

## 🐣10.1 객체의 역할
### ☁️10.1.1 호스트 객체
클래스 멤버 함수를 정의했다면, 인스턴스 앞에 점을 찍고 멤버 함수를 호출한다.
```cpp
void Fun::functionOne(...)
{
    ...
}

int main()
{
    fun1.functionOne(...); // fun1이 호스트 객체
    fun2.functionOne(...); // fun2이 호스트 객체
    fun3.functionOne(...);
}
```
> 호스트 객체는 **함수 호출의 주체**라고 할 수 있다.

---
### ☁️10.1.2 매개변수 객체(parameter object)
매개변수로 전달된 객체.
매개변수는 값으로 전달, 참조로 전달, 포인터로 전달이라는 3가지 방법으로 전달한다.
#### 전달 방법
- 값으로 전달
    - 복사 생성자를 호출하여 객체의 복사본을 만들고, 이를 함수로 전달
    - 복사 비용 크다.
    - 일반적으로 매개변수가 객체일 때는 사용하지 않는다.
- 참조로 전달
    - 사용자 정의 객체를 함수로 전달할 때 사용하는 일반적 방법
    - 값 복사x, 객체에 별칭을 붙여 함수 내부에서 사용할 수 있게 한다.
- 포인터로 전달
    - **객체를 힙에 만들어 객체를 가리키는 포인터가 있을 때 사용**
    - 일반적인 경우에는 사용 안한다.

### ☁️10.1.3 리턴 객체(return object)
생성자와 소멸자는 객체를 리턴하지 않고,
객체를 생성하거나 소멸시키는 역할을 한다.
#### 리턴 방법
객체를 리턴할 때도 값으로 리턴, 참조로 리턴, 포인터로 리턴이라는 3가지 방법을 사용할 수 있다.
- 값으로 리턴
    - 복사 생성자를 호출하여 객체 복사본 만들고 리턴
    - 리턴하는 객체를 함수 내부에서 만들 경우 참조로 리턴과 포인터로 리턴을 사용할 수 없으므로 값으로 리턴만 사용 가능하다.
        - 지역 객체는 함수가 끝나면 메모리에서 사라지기 때문
- 참조로 리턴
    - 복사 비용이 없지만, 함수 내부에서 객체를 생성하는 경우에는 사용 불가
    - 매개변수로 전달받은 객체(or 포인터)와 호스트 객체(or 포인터)를 리턴할 경우는 사용 가능하다.
- 포인터로 리턴
    - 객체를 힙에 만들어서 객체를 가리키는 포인터가 있을 때 사용한다.
    - 일반적인 경우에는 거의 사용 안한다.

### ☁️10.1.4 함수명 앞 const
#### 위치별 const
| 위치                 | 의미                                         |
| ------------------ | ------------------------------------------ |
| 함수명 **뒤** `const`  | **멤버 함수가 객체의 멤버 변수를 변경하지 않겠다**는 약속         |
| 매개변수 **앞** `const` | 해당 매개변수를 함수 내부에서 변경하지 않겠다는 약속              |
| 함수명 **앞** `const`  | **함수가 반환하는 값을 변경할 수 없다**는 뜻 (반환 타입이 const) |

```cpp
class Test
{
public:
    const int getValue() {return 42;}
};

int main()
{
    Test t;
     std::cout << t.getValue() << std::endl; //42
    t.getValue() = 100; // 컴파일 에러
    return 0;
}
```
- 함수명 앞의 const는 사실상 **"반환 타입에 const를 붙인 것"**
- 반환 타입이 포인터나 참조일 때 유용하다.
    - ```cpp
        const string& getName() {return name;}
        ```
    - 이렇게 하면 `getName()`으로 받은 문자열을 수정하려고 하면 오류난다.

---
## 🐣10.2 연산자 오버로드
<span style="background-color:#fffff0">**사용자 정의 타입(클래스, 구조체)을 기본 자료형처럼 자연스럽게 다루기 위함** </span>

### ☁️10.2.1 연산자 오버로드를 왜 배우는가
#### 1. 객체를 자연스럽게 사용 가능
- `int a = 3 + 5;`
- `Money m1(1000), m2(2000); m1 + m2;`
    - 둘 다 같은 느낌으로 사용 가능하지만,</br>후자는 클래스에서 `operator+`를 오버로드해야 가능하다.
#### 2. 가독성과 유지보수성 향상
- 연산자 오버로드가 없을때
```cpp
Vector3 pos3 = pos1.add(pos2);
```
- 연산자 오버로드 적용 시
```cpp
Vector3 pos3 = pos1 + pos2;
```
---
### ☁️10.2.2 문법 구조
#### 기본 형태
> 반환형 <span style="color:blueviolet"> operator </span> 연산자(매개변수) { . . . }

- `operator` 키워드 뒤에 오버로드할 연산자를 붙인다.
    - `+`, `-`, `==`, `[]`, `()`, `<<`, `>>`
    - 매개변수 개수는 해당 연산자의 원래 피연산자 수와 맞춘다.

### ☁️10.2.2 문법 구조

### ☁️10.2.2 문법 구조


