# Chapter06 - friend와 static 그리고 const
## 🐻‍❄️6.1 const(상수화)
### 💠개념
- 변수 앞에 붙으면 그 변수는 값을 변경할 수 없는 **상수**가 된다.
- 멤버 함수 **뒤**에 붙으면 그 함수 안에서 멤버 변수 값을 변경하지 않겠다는 의미
- 포인터와 함께 쓰이면 여러 경우가 있는데 따로 정리

### 💠특징
- 의도하지 않은 데이터 변경 방지</br>
→ 코드 안전성 향상
- 함수 오버로딩 시, `const`멤버 함수와 `non-const`멤버 함수 구분 가능

---
## 🐻‍❄️6.2 const 객체
| C++에서 `const객체`는 **컴파일러가 코드 수준에서 "읽기 전용"으로 강제하는 객체**이다.</br>
물리적인 메모리 보호보다는 컴파일 타임에서 제한하는 문법적 약속에 가깝다.

### 💠6.2.1 const 객체란?
이렇게 선언된 객체를 **상수 객체(constant object)** 라고 한다.
```cpp
const ClassName obj(...);
```
- 이 객체는 생성 이후 **멤버 데이터를 절대로 수정할 수 없다**
- 멤버 변수에 직접 접근해도 변경할 수 없고(컴파일 에러),</br>
**멤버 함수도 오직 const 멤버 함수만 호출할 수 있다.**
  - 내부 멤버 전체가 const로 간주되는 것(읽기 전용)
  - 컴파일 타임에 타입체크를 통해 강제한다

### 💠6.2.2 const 객체의 내부 처리
```cpp
class User{
private:
    string name;
public:
    void setName(string n){name = n;}
    void printName() const { cout << name << endl;}
};
```
여기서 `printName()`은 `const`함수니까 `const User`객체에서 호출 가능하다.</br>
왜냐하면 const함수는 내부적으로
```cpp
// 컴파일러가 이렇게 변환한다.
void printName(const User* this);
```
이렇게 처리되기 때문이다.</br>
하지만 일반 함수 `setName`은
```cpp
// 일반 포인터
void setName(User* this);
```
- const 객체는 `const User* this`를 넘겨준다.
- 일반 함수는 `User* this`를 필요로 한다.

| 즉, const 객체는 **this 포인터가 const 포인터**이기 때문에 non-const함수의 시그니처와 맞지 않아 호출이 불가능하다.</br>
_**→함수 포인터 타입이 안 맞아서 호출 불가**_

---
## 🐻‍❄️6.3 static
### 💠6.3.1 static 키워드란
static은 **"정적(static)"**이라는 의미로,</br> **메모리 생명 주기**와 **접근 범위**를 제어하는 키워드다. </br>
사용 위치에 따라 의미가 달라진다.
| 사용 위치      | 의미                     |
| ---------- | ---------------------- |
| 함수 내부      | 값이 유지되는 지역 변수          |
| 클래스 내부 변수  | 객체 간 공유되는 멤버 변수        |
| 클래스 내부 함수  | 객체 없이 호출 가능한 정적 함수     |
| 전역 변수 / 함수 | 해당 소스 파일에서만 접근 가능하게 제한 |

### 💠함수 내부 static
- 함수 내에 선언되지만, **스택**이 아닌 **데이터(static)** 영역에 저장
  - 일반 지역변수는 스택에 저장, 함수 끝나면 소멸
  - static 지역 변수는 **데이터 영역에 저장, 프로그램 종료까지 유지**
- 함수가 호출될 때마다 **초기화되지 않는다** → 이전 값 유지
- **최초 한 번만 초기화**, 이후는 재사용

```cpp
void testFunc()
{
  static int count = 0;
  count++;
  cout << "count : " << count << endl;

  /*실행 예시
  testFunc();  // count: 1
  testFunc();  // count: 2  
  testFunc();  // count: 3
  */
}
```
---
### 💠6.3.2 static 멤버 변수(클래스 안)
- 객체마다 따로 존재하지 않고</br>
**클래스 전체에서 단 하나만 존재**
- 모든 객체가 이 변수를 공유한다

#### 🌟static 멤버 변수는 클래스 안에서 선언만 하고, 반드시 외부에서 정의를 따로 해줘야 한다.

- 일반 멤버 변수는 객체마다 개별적으로 존재하지만
-  `static`멤버 변수는 **클래스 전체에서 공유**되므로,</br>
**객체가 몇 개든 딱 하나의 메모리 공간만 필요하다**
- 따라서 **클래스 안에서는 선언만 하고, 이 변수를 위한 메모리 공간을 어딘가에 한 번만 따로 만들어 주는 것**
- 만약 클래스 안에서 static변수를 정의해버리면, 여러 곳에서 정의되므로 **링커 에러(duplicate symbol)가 발생한다.

```cpp
class Counter
{
private:
  static int count;

public:
  Counter()
  {
    count++;
  }

  static void showCount()
  {
    cout << " Total : " << cout << endl;
  }

  // 클래스 외부 정의
  int Counter::count = 0;
}
```

#### 예외적으로 클래스 안에서 정의가 가능한 경우
```cpp
class A {
    static const int SIZE = 100;  // 상수는 예외!
};
```
- `static const int`는 **컴파일 시간 상수**
- 실제로 메모리 공간이 필요한 게 아니라, 상수값을 치환해서 쓰는 수준이기 때문
- 따라서 클래스 내부에서도 초기화 가능하다

---
### 💠6.3.3 static 멤버 함수
| 객체가 아닌 **클래스 자체에 속하는 함수**이다.</br> 객체를 만들지 않아도 호출할 수 있고, 객체마다 따로 존재하지 않고 **공통적으로 하나만 존재한다**
- **객체가 아닌 클래스 단위로 공유된다.**
  - 객체 없이도 `ClassName::function()` 형태로 호출 가능
- `this`포인터가 없음 → **멤버 변수 접근 불가**
  - `this`는 객체를 가리키기 때문
- **static 함수 안에서는 일반 멤버 변수/함수에 접근 불가하다**
  - 오직 static 변수나 외부 변수, 전달인자만 사용 가능하다

#### 🖥️객체 없이도 호출되는 static함수
```cpp
#include <iostream>
using namespace std;

class Counter
{
private:
  static int count; // static 멤버 변수

public:
  static void increment() {count++;}
  static void showCount() const
  {
    cout << "Count : " << count << endl;
  }
}

int main()
{
  // 객체 생성 없이도 호출 가능
  Counter::showCount();
  Counter::increment();
  Counter::increment();
  Counter::showCount();
}
```