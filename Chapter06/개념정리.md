# Chapter06 - friend와 static 그리고 const
## 🐻‍❄️6.1 const(상수화)
### 💠개념
- 변수 앞에 붙으면 그 변수는 값을 변경할 수 없는 **상수**가 된다.
- 멤버 함수 **뒤**에 붙으면 그 함수 안에서 멤버 변수 값을 변경하지 않겠다는 의미
- 포인터와 함께 쓰이면 여러 경우가 있는데 따로 정리

### 💠특징
- 의도하지 않은 데이터 변경 방지</br>
→ 코드 안전성 향상
- 함수 오버로딩 시, `const`멤버 함수와 `non-const`멤버 함수 구분 가능

---
## 🐻‍❄️6.2 const 객체
| C++에서 `const객체`는 **컴파일러가 코드 수준에서 "읽기 전용"으로 강제하는 객체**이다.</br>
물리적인 메모리 보호보다는 컴파일 타임에서 제한하는 문법적 약속에 가깝다.

### 💠6.2.1 const 객체란?
이렇게 선언된 객체를 **상수 객체(constant object)** 라고 한다.
```cpp
const ClassName obj(...);
```
- 이 객체는 생성 이후 **멤버 데이터를 절대로 수정할 수 없다**
- 멤버 변수에 직접 접근해도 변경할 수 없고(컴파일 에러),</br>
**멤버 함수도 오직 const 멤버 함수만 호출할 수 있다.**
  - 내부 멤버 전체가 const로 간주되는 것(읽기 전용)
  - 컴파일 타임에 타입체크를 통해 강제한다

### 💠6.2.2 const 객체의 내부 처리
```cpp
class User{
private:
    string name;
public:
    void setName(string n){name = n;}
    void printName() const { cout << name << endl;}
};
```
여기서 `printName()`은 `const`함수니까 `const User`객체에서 호출 가능하다.</br>
왜냐하면 const함수는 내부적으로
```cpp
// 컴파일러가 이렇게 변환한다.
void printName(const User* this);
```
이렇게 처리되기 때문이다.</br>
하지만 일반 함수 `setName`은
```cpp
// 일반 포인터
void setName(User* this);
```
- const 객체는 `const User* this`를 넘겨준다.
- 일반 함수는 `User* this`를 필요로 한다.

| 즉, const 객체는 **this 포인터가 const 포인터**이기 때문에 non-const함수의 시그니처와 맞지 않아 호출이 불가능하다.</br>
_**→함수 포인터 타입이 안 맞아서 호출 불가**_

