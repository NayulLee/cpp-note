# 1. 예외 처리의 개요
> "프로그램은 보수적으로 짜야한다"

숙련된 개발자는 테스트 데이터를 활용해 프로그램을 테스트하기 전까지는 프로그램의 문제 가능성을 계속해서 생각한다.

## 🐻‍❄️1.1 고전적인 오류 처리 방법
구문 오류가 없다면 프로그램은 컴파일된다</br>
그렇다해도 실행중에 오류가 발생할 수 있고, 이 경우 프로그램은 중단된다. </br>
이러한 런타임 오류를 처리하기 위해 고전적으로 사용되는 4가지 오류 처리 방법
### 💠1.1.1 런타임 때 프로그램을 중단
```cpp
int num1, num2, result;
    for(int i = 0; i < 5; i++)
    {
        cout << "정수를 입력하세요 : ";
        cin >> num1;
        cout << "또 다른 정수를 입력하세요 : ";
        cin >> num2;
        result = num1 / num2; // 예외 발생 가능성!
        cout << "결과 = " << result << endl;
    }
```
- 또 다른 정수에 0을 입력할 경우 프로그램이 강제 종료된다.

### 💠1.1.2 런타임때 프로그램 중단 요청
예상할 수 있는 오류를 조건문 등으로 처리한 후, 프로그램 중단을 요청한다.</br>
이렇게 하면 프로그램이 중단되는 원ㅇ니을 설명할 수 있다.
```cpp
#include <cassert>
  if(num2 == 0)
       {
            cout << "0으로 나눌 수 없음, 프로그램을 중단합니다" << endl;
            assert(false);
       }
```
- `assert` 매크로로 프로그램이 중단되게 요청

### 💠1.1.3  오류 확인 사용
반복 때 두 번째 숫자의 값을 확인하고, 0일 때에 나누지 않고 넘어가는 것</br>
프로그램이 중단되지 않고 계속되므로 이전 방법보단 좋다
```cpp
if(num2 == 0)
{
    cout << "현재 입력으로는 처리가 불가능합니다" << endl;
}
else
{
    result = num1 / num;
    cout << "결과 :" << result;
}
```
### 💠1.1.4 오류 확인에 함수 리턴 사용
과거에는 어떤 값을 계산하고, 리턴값을 활용하여 오류를 확인하는 방법을 사용했다
```cpp
int quotient(int first, int second);

int main()
{
    int num1, num2, result;
        result = quotient(num1, num2);
        if(result == -1)
        {
            cout << "오류! 0으로 나눌 수 없습니다";
        }
        else
        {
            cout << "결과 = " << result << endl;
        }     
    return 0;
}

int quotient(int first, int second)
{
    if(second == 0)
    {
        return -1;
    }
    return (first/second);
}
```
- 앞선 고전적인 처리 방법중에서는 가장 좋으나, 모든 상황에서 사용할 수 있는 형태는 아니다.
- **구조적 프로그래밍 원칙**에 따르면</br>**함수의 리턴값은 하나의 목적만 가져야 한다**
    - 이 방법은 1.. 오류를 발견하기 위한 목적과 2. 계산을 하기 위한 목적이라는 2가지 목적으로 리턴값을 사용하므로 </br>구조적 프로그래밍 원칙에 위배된다.

---
## 🐻‍❄️1.2 C++의 예외 처리 방법
예외 처리 방법을 사용하면 런타임 때 예외가 발생해도 프로그램이 이를 처리하여 중단되지 않게 만들 수 있다.

### 💠1.2.1 try-catch 블록
> c++은 `try-catch` 블록이라는 예외 처리 방법을 사용한다

- `try`절에는 프로그램을 중단시킬 가능성이 있는 코드를 넣는다.
- 런타임 환경은 try절의 코드를 실행하다 예외가 발생하면 `catch`절로 이동하여 코드 계속 진행

---
### 💠1.2.2 throw 연산자
 프로그램 실행 중 **비정상적인 상황**이 발상했음을 알리고,
그 정보를 **예외 객체(exception object)**형태로 던진다.

던져진 예외는 **catch**가 받아 처리한다.

```cpp
throw 표현식;
```
- `표현식`은 예외로 전달할 값(객체)
- 던지는 타입은 `catch`블록에서 형식(type)으로 구분해서 잡는다
- `throw;`(표현식 없이)라는 특별한 형태도 있는데, 이건</br>**현재 처리 중인 예외를 다시 던질 때** 사용한다.

#### 특징1. 타입에 따라 다르게 처리된다.
- ex. `throw int(1);`과 `throw std::runtime_error("error");`는 각각 `catch(int e)`와 `catch(std::runtime_error& e)`로 다르게 잡아야한다.
#### 특징2. 스택 언와인딩(stack unwinding)
- 예외가 던져질 때, 예외가 발생한 지점부터 `catch`블록을 찾을 때까지 함수 호출 스택을 거슬러 올라가며 객체들이 차례대로 소멸된다.
  - 지역 객체 소멸자 호출됨
#### 특징3. catch와 반드시 짝을 이뤄야함
- 반드시 어딘가에서 받아줘야(throw) 정상적인 종료가 가능하다.
- 받지 않으면 프로그램이 `std::terminate()`를 호출하며 강제 종료됨.

---
### 💠1.2.3 예외 처리 패턴1 : main함수 내부
```cpp
int main()
{
    int num1, num2, result;
    for(int i = 0; i < 5; i++)
    {
        cout << "정수를 입력하세요 : ";
        cin >> num1;
        cout << "또 다른 정수를 입력하세요 : ";
        cin >> num2;
        try
        {
            if(num2 == 0)  throw 0;    // int 자료형의 예외를 발생
            result = num1 / num2;
            cout << "결과 : " << result << endl;
        }
        catch(const int e)
        {
            cout << "0으로 나눌 수 없습니다" << endl;
        }  
    }
    return 0;
}
```
### 💠1.2.4 예외 처리 패턴2 : 다른 함수에서 예외 throw
다른 함수 내부에서 예외가 throw될 경우  함수 내부의 나머지 코드는 모두 무시되고 곧바 `catch`절로 코드의 실행 흐름이 이동한다.

- 일반적으로 구조적 프로그래밍 원칙에 따르는 코드를 작성할 때 권장되는 패턴
- 연산 처리와 관련된 내용은 호출되는 함수 쪽에 있고,</br>
문제가 있는 경우 문제를 호출하는 함수 쪽에서 처리하므로, **연산과 예외 처리가 분리**되기 때문이다.
```cpp
int main()
{
    int num1, num2, result;
    for(int i = 0; i < 5; i++)
    {
        cout << "정수를 입력하세요 : ";
        cin >> num1;
        cout << "또 다른 정수를 입력하세요 : ";
        cin >> num2;
        try
        {
            cout << "결과 : " << quotient(num1, num2) << endl;
        }
        catch(const int e)
        {
            cout << "0으로 나눌 수 없습니다" << endl;
        }  
    }
    return 0;
}

int quotient(int first, int second)
{
    if(second == 0) throw 0;
    return first / second;
}
```
- 어떤 함수의 코드를 공개하지 않고 라이브러리 형태로 제공만 하는 경우, </br>
사용자에게 함수가 무엇을 하는 지 알려주고(공용 인터페이스) 어떤 예외가 발생하는지 알려줄 수 있다.

### 💠1.2.5 예외 처리 패턴3 : 호출되는 함수에서 try-catch


---
### 💠1.2.6 예외 전파(propagation), 예외 전달(handling)
> 예외는 꼭 발생한 함수에서 바로 처리할 필요는 없다. 처리할 수 있는 함수가 나타날 때까지 함수 호출 스택을 따라 위로 전파된다. 최종적으로 `main`함수까지 올라갈 수 있으며 그래도 잡히지 않으면 프로그램은 종료된다.
#### 1. 예외 전파(Exception Propagation)
어떤 함수 안에서 `throw`가 발생했는데, 그 함수 내부에 `try-catch`가 없다면 예외는 해당 함수 **바깥**으로 전달된다.
- **호출한 함수 쪽으로 예외가 튕겨 올라가는 것**을 의미
- 이 과정에서 C++은 호출 스택을 거슬러 올라가면서 지역 객체들의 소멸자를 호출하는데</br>
이를 <span style="background-color:#F5F5F5"> 스택 언와인딩(stack unwinding) </span>이라고 한다.

#### 2. 예외 전달(Exception Handling/Catching)
- 전파된 예외는 **어딘가에서 받아야 한다.**
- `catch`블록이 바로 **예외 전달(handling)**을 담당한다.
- 즉, 예외 전파는 "예외가 올라가는 과정"</br>
예외 전달은 "catch에서 실제로 받는 것"

---
### 💠1.2.7 예외 사양(Exception Specification)
**"이 함수가 어떤 예외를 던질 수 있는지(혹은 안 던지는지)를 함수 선언부에 명시하는 것"**

함수 인터페이스 차원에서</br>
"이 함수는 아무 예외나 던질 수 있다" vs "절대 예외를 던지지 않는다" 를 알려주는 문법

>C++11부터 기존의 예외 사양  문법은 모두 폐지되고 `noexcept`키워드 도입

#### 1. 모든 예외 발생 가능(기본 상태)
```cpp
void func();    // 아무 예외 사양도 없다
```
- 기본적으로 함수는 **예외를 던질 수 있다**고 가정
- `throw`되는 예외 타입에 제한이 없음
- 별도로 선언 필요 x

#### 2. 특정 예외만 발생 가능
```cpp
void func() throw(std::runtime_error);