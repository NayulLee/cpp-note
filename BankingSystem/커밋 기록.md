# 🗓️2025-08-19 커밋 기록
## ❔현재 코드에 다형성이 구현되어 있는가?
> → 전혀 안돼있음!
### 이유
#### 1. 상속 구조가 없다
- `Account`클래스 하나만 있고, 이를 상속받은 다른 계좌 타입
    - ex. `SavingAccount`, `CheckingAccount`같은 파생 클래스 없다

#### 2. 가상함수(virtual)없음
- 다형성의 핵심인**동적 바인딩**을 위해서는 'virtual'함수가 필요하지만</br>
현재 코드의 모든 멤버 함수는 일반 함수이다.
#### 3. 함수 호출이 모두 정적 바인딩
- 예를 들어 `accArr[i]->Deposit(money)`호출 시, 컴파일 시점에 어떤 함수가 호출될지 이미 결정된다.
- 즉 **런타임에 객체 타입에 따라 다른 함수가 호출되는 동적 다형성X**

> 현재 상태로는 **모든 계좌는 동일한 `Account`타입**으로 취급되고
**계좌 종류에 따라 다른 행동을 하도록 확장**하려 해도 구조적으로 불가능하다.

---
## ❔코드 구조를 객체지향적으로 바꿔보자
```cpp
AccountHandler {
    Account* accArr[100];
    int accNum;
    void makeAccount();
    void depositMoney();
    ...
}
```
### 변경점
> 1. 전역 변수를 **멤버 변수로 이동** → 캡슐화
> 2. 메뉴 관련 함수들을 **클래스 멤버 함수**로 이동 -> 관리 일원화

- 단순히 코드 구조를 객체지향적으로 바꾸는 과정

---
# 🗓️2025-08-20 커밋 기록
## 다형성 구현 - 코드 리팩토링
기존은 Account클래스만 존재했었다.(코드 다형성x)
- Account클래스를 상속하는 NormalAccount, HighCreditAccount를 추가!
### 재사용 측면
- 자식/자손 클래스가 부모 클래스의 멤버 함수를 그대로 호출한다.
    - `Account::Deposit(money))`해서 기존 기능 재사용
    - 추가 기능만 덧붙이는 형태로 코드 중복을 최소화한다.
### 업케스팅
- 부모 클래스 포인터 `Account*`로 자식/자손 객체를 가리키고</br>
가상 함수를 호출할 때 실제 객체 타입에 맞는 함수가 **런타임**에 선택된다.

## 알아둘 점
### virtual
- 가상함수 `virtual`은 부모 클래스의 멤버함수에만 붙여주면 
**손자까지 계속 가상 함수 속성이 이어진다.**
    - 자식함수에 `override`키워드 붙이는거 반드시 습관화하자
- 헤더에서 `virtual` 붙이면 구현부에서는 안붙여도 된다.

--- 
# 🗓️2025-08-21 커밋 기록
## 클래스별 헤더/구현파일 분리
- 실무나 확장 프로젝트에서는 클래스별 파일로 나누는 것이 표준이다.
- 공통 상수나 enum 은 별도의 헤더를 사용한다.
